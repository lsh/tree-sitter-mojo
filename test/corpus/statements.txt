================================================================================
Import statements
================================================================================

import a, b
import b.c as d
import a.b.c

--------------------------------------------------------------------------------

(module
  (import_statement
    (dotted_name
      (identifier))
    (dotted_name
      (identifier)))
  (import_statement
    (aliased_import
      (dotted_name
        (identifier)
        (identifier))
      (identifier)))
  (import_statement
    (dotted_name
      (identifier)
      (identifier)
      (identifier))))

================================================================================
Import-from statements
================================================================================

from a import b
from a import *
from a import (b, c)
from a.b import c
from . import b
from .. import b
from .a import b
from ..a import b

--------------------------------------------------------------------------------

(module
  (import_from_statement
    (dotted_name
      (identifier))
    (dotted_name
      (identifier)))
  (import_from_statement
    (dotted_name
      (identifier))
    (wildcard_import))
  (import_from_statement
    (dotted_name
      (identifier))
    (dotted_name
      (identifier))
    (dotted_name
      (identifier)))
  (import_from_statement
    (dotted_name
      (identifier)
      (identifier))
    (dotted_name
      (identifier)))
  (import_from_statement
    (relative_import
      (import_prefix))
    (dotted_name
      (identifier)))
  (import_from_statement
    (relative_import
      (import_prefix))
    (dotted_name
      (identifier)))
  (import_from_statement
    (relative_import
      (import_prefix)
      (dotted_name
        (identifier)))
    (dotted_name
      (identifier)))
  (import_from_statement
    (relative_import
      (import_prefix)
      (dotted_name
        (identifier)))
    (dotted_name
      (identifier))))

================================================================================
Future import statements
================================================================================

from __future__ import print_statement
from __future__ import python4
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
--------------------------------------------------------------------------------

(module
  (future_import_statement
    (dotted_name
      (identifier)))
  (future_import_statement
    (dotted_name
      (identifier)))
  (future_import_statement
    (dotted_name
      (identifier))
    (dotted_name
      (identifier))
    (dotted_name
      (identifier))
    (dotted_name
      (identifier))))

================================================================================
Print statements
================================================================================

print a
print b, c
print 0 or 1, 1 or 0,
print 0 or 1
print not True

--------------------------------------------------------------------------------

(module
  (print_statement
    (identifier))
  (print_statement
    (identifier)
    (identifier))
  (print_statement
    (boolean_operator
      (integer)
      (integer))
    (boolean_operator
      (integer)
      (integer)))
  (print_statement
    (boolean_operator
      (integer)
      (integer)))
  (print_statement
    (not_operator
      (true))))

================================================================================
Print statements with redirection
================================================================================

print >> a
print >> a, "b", "c"

--------------------------------------------------------------------------------

(module
  (print_statement
    (chevron
      (identifier)))
  (print_statement
    (chevron
      (identifier))
    (string
      (string_start)
      (string_content)
      (string_end))
    (string
      (string_start)
      (string_content)
      (string_end))))

================================================================================
Assert statements
================================================================================

assert a
assert b, c

--------------------------------------------------------------------------------

(module
  (assert_statement
    (identifier))
  (assert_statement
    (identifier)
    (identifier)))

================================================================================
Expression statements
================================================================================

a
b + c
1, 2, 3
1, 2, 3,

--------------------------------------------------------------------------------

(module
  (identifier)
  (binary_operator
    (identifier)
    (identifier))
  (tuple_expression
    (integer)
    (integer)
    (integer))
  (tuple_expression
    (integer)
    (integer)
    (integer)))

================================================================================
Delete statements
================================================================================

del a[1], b[2]

--------------------------------------------------------------------------------

(module
  (delete_statement
    (expression_list
      (subscript
        (identifier)
        (integer))
      (subscript
        (identifier)
        (integer)))))

================================================================================
Control-flow statements
================================================================================

while true:
  pass
  break
  continue

--------------------------------------------------------------------------------

(module
  (while_statement
    condition: (identifier)
    body: (block
      (pass_statement)
      (break_statement)
      (continue_statement))))

================================================================================
Return statements
================================================================================

return
return a + b, c
return not b

--------------------------------------------------------------------------------

(module
  (return_statement)
  (return_statement
    (expression_list
      (binary_operator
        (identifier)
        (identifier))
      (identifier)))
  (return_statement
    (not_operator
      (identifier))))

================================================================================
If statements
================================================================================

if a:
  b
  c

--------------------------------------------------------------------------------

(module
  (if_statement
    condition: (identifier)
    consequence: (block
      (identifier)
      (identifier))))

================================================================================
If else statements
================================================================================

if a:
  b
elif c:
  d
else:
  f

if a:
  b
else:
  f

if a: b

if a: b; c

--------------------------------------------------------------------------------

(module
  (if_statement
    condition: (identifier)
    consequence: (block
      (identifier))
    alternative: (elif_clause
      condition: (identifier)
      consequence: (block
        (identifier)))
    alternative: (else_clause
      body: (block
        (identifier))))
  (if_statement
    condition: (identifier)
    consequence: (block
      (identifier))
    alternative: (else_clause
      body: (block
        (identifier))))
  (if_statement
    condition: (identifier)
    consequence: (block
      (identifier)))
  (if_statement
    condition: (identifier)
    consequence: (block
      (identifier)
      (identifier))))

================================================================================
Nested if statements
================================================================================

if a:
  if b:
    c
  else:
    if e:
      f
g

--------------------------------------------------------------------------------

(module
  (if_statement
    condition: (identifier)
    consequence: (block
      (if_statement
        condition: (identifier)
        consequence: (block
          (identifier))
        alternative: (else_clause
          body: (block
            (if_statement
              condition: (identifier)
              consequence: (block
                (identifier))))))))
  (identifier))

================================================================================
While statements
================================================================================

while a:
  b

while c:
  d
else:
  e
  f

--------------------------------------------------------------------------------

(module
  (while_statement
    condition: (identifier)
    body: (block
      (identifier)))
  (while_statement
    condition: (identifier)
    body: (block
      (identifier))
    alternative: (else_clause
      body: (block
        (identifier)
        (identifier)))))

================================================================================
For statements
================================================================================

for line, i in lines:
  print line
  for character, j in line:
    print character
else:
  print x

for x, in [(1,), (2,), (3,)]:
  x

--------------------------------------------------------------------------------

(module
  (for_statement
    left: (pattern_list
      (identifier)
      (identifier))
    right: (identifier)
    body: (block
      (print_statement
        argument: (identifier))
      (for_statement
        left: (pattern_list
          (identifier)
          (identifier))
        right: (identifier)
        body: (block
          (print_statement
            argument: (identifier)))))
    alternative: (else_clause
      body: (block
        (print_statement
          argument: (identifier)))))
  (for_statement
    left: (pattern_list
      (identifier))
    right: (list
      (tuple
        (integer))
      (tuple
        (integer))
      (tuple
        (integer)))
    body: (block
      (identifier))))

================================================================================
Try statements
================================================================================

try:
  a
except b:
  c
except d as e:
  f
except g, h:
  i
except:
  j

try:
  a
except b:
  c
  d
else:
  e
finally:
  f

try:
  a
except* b:
  c
except* d as e:
  f
else:
  g
finally:
  h

--------------------------------------------------------------------------------

(module
  (try_statement
    body: (block
      (identifier))
    (except_clause
      (identifier)
      (block
        (identifier)))
    (except_clause
      (as_pattern
        (identifier)
        comptime: (as_pattern_target
          (identifier)))
      (block
        (identifier)))
    (except_clause
      (identifier)
      (identifier)
      (block
        (identifier)))
    (except_clause
      (block
        (identifier))))
  (try_statement
    body: (block
      (identifier))
    (except_clause
      (identifier)
      (block
        (identifier)
        (identifier)))
    (else_clause
      body: (block
        (identifier)))
    (finally_clause
      (block
        (identifier))))
  (try_statement
    body: (block
      (identifier))
    (except_group_clause
      (identifier)
      (block
        (identifier)))
    (except_group_clause
      (as_pattern
        (identifier)
        comptime: (as_pattern_target
          (identifier)))
      (block
        (identifier)))
    (else_clause
      body: (block
        (identifier)))
    (finally_clause
      (block
        (identifier)))))

================================================================================
With statements
================================================================================

with a as b:
  c

with (open('d') as d,
      open('e') as e):
  f

with e as f, g as h,:
  i

--------------------------------------------------------------------------------

(module
  (with_statement
    (with_clause
      (with_item
        (as_pattern
          (identifier)
          (as_pattern_target
            (identifier)))))
    (block
      (identifier)))
  (with_statement
    (with_clause
      (with_item
        (as_pattern
          (call
            (identifier)
            (argument_list
              (string
                (string_start)
                (string_content)
                (string_end))))
          (as_pattern_target
            (identifier))))
      (with_item
        (as_pattern
          (call
            (identifier)
            (argument_list
              (string
                (string_start)
                (string_content)
                (string_end))))
          (as_pattern_target
            (identifier)))))
    (block
      (identifier)))
  (with_statement
    (with_clause
      (with_item
        (as_pattern
          (identifier)
          (as_pattern_target
            (identifier))))
      (with_item
        (as_pattern
          (identifier)
          (as_pattern_target
            (identifier)))))
    (block
      (identifier))))

================================================================================
Async Function definitions
================================================================================

async def a():
  b

async def c(d):
  e

async def g(g, h,):
  i

async def c(a: str):
  a

async def c(a: b.c):
  a

async def d(a: Sequence[T]) -> T:
  a

async def i(a, b=c, *c, **d):
  a

async def d(a: str) -> None:
  return None

async def d(a:str="default", b=c) -> None:
  return None

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (attribute
            object: (identifier)
            attribute: (identifier)))))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (generic_type
            (identifier)
            (type_parameter
              (type
                (identifier)))))))
    return_type: (type
      (identifier))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (default_parameter
        name: (identifier)
        value: (identifier))
      (list_splat_pattern
        (identifier))
      (dictionary_splat_pattern
        (identifier)))
    body: (block
      (identifier)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (none))
    body: (block
      (return_statement
        (none))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_default_parameter
        name: (identifier)
        type: (type
          (identifier))
        value: (string
          (string_start)
          (string_content)
          (string_end)))
      (default_parameter
        name: (identifier)
        value: (identifier)))
    return_type: (type
      (none))
    body: (block
      (return_statement
        (none)))))

================================================================================
Function definitions
================================================================================

def e((a,b)):
  return (a,b)

def e(*list: str):
  pass

def e(**list: str):
  pass

def f():
  nonlocal a

def g(h, i, /, j, *, k=100, **kwarg):
  return h,i,j,k,kwarg

def h(*a):
  i((*a))
  j(((*a)))

def foo():
    pass \
\
\

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (tuple_pattern
        (identifier)
        (identifier)))
    body: (block
      (return_statement
        (tuple
          (identifier)
          (identifier)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (list_splat_pattern
          (identifier))
        type: (type
          (identifier))))
    body: (block
      (pass_statement)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (dictionary_splat_pattern
          (identifier))
        type: (type
          (identifier))))
    body: (block
      (pass_statement)))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (nonlocal_statement
        (identifier))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier)
      (positional_separator)
      (identifier)
      (keyword_separator)
      (default_parameter
        name: (identifier)
        value: (integer))
      (dictionary_splat_pattern
        (identifier)))
    body: (block
      (return_statement
        (expression_list
          (identifier)
          (identifier)
          (identifier)
          (identifier)
          (identifier)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (list_splat_pattern
        (identifier)))
    body: (block
      (call
        function: (identifier)
        arguments: (argument_list
          (parenthesized_expression
            (list_splat
              (identifier)))))
      (call
        function: (identifier)
        arguments: (argument_list
          (parenthesized_expression
            (parenthesized_expression
              (list_splat
                (identifier))))))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (pass_statement)))
  (line_continuation)
  (line_continuation)
  (line_continuation))

================================================================================
Mojo Function Definitions
================================================================================

fn e[IntableType: Intable](a: IntableType) -> Int:
  return int(a)

fn e(*list: String):
  pass

fn e(**list: String):
  pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier)))))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (call
          function: (identifier)
          arguments: (argument_list
            (identifier))))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (list_splat_pattern
          (identifier))
        type: (type
          (identifier))))
    body: (block
      (pass_statement)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (dictionary_splat_pattern
          (identifier))
        type: (type
          (identifier))))
    body: (block
      (pass_statement))))

================================================================================
Empty blocks
================================================================================

# These are not actually valid python; blocks
# must contain at least one statement. But we
# allow them because error recovery for empty
# blocks doesn't work very well otherwise.
def a(b, c):

if d:
  print e
  while f():

--------------------------------------------------------------------------------

(module
  (comment)
  (comment)
  (comment)
  (comment)
  (function_definition
    name: (identifier)
    parameters: (parameters
      (identifier)
      (identifier))
    body: (block))
  (if_statement
    condition: (identifier)
    consequence: (block
      (print_statement
        argument: (identifier))
      (while_statement
        condition: (call
          function: (identifier)
          arguments: (argument_list))
        body: (block)))))

================================================================================
Class definitions
================================================================================

class A:
  def b(self):
    return c
class B():
  pass
class B(method1):
  def method1(self):
    return
class C(method1, Sequence[T]):
  pass
class D(Sequence[T, U]):
  pass

--------------------------------------------------------------------------------

(module
  (class_definition
    (identifier)
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter))
        (block
          (return_statement
            (identifier))))))
  (class_definition
    (identifier)
    (argument_list)
    (block
      (pass_statement)))
  (class_definition
    (identifier)
    (argument_list
      (identifier))
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter))
        (block
          (return_statement)))))
  (class_definition
    (identifier)
    (argument_list
      (identifier)
      (subscript
        (identifier)
        (identifier)))
    (block
      (pass_statement)))
  (class_definition
    (identifier)
    (argument_list
      (subscript
        (identifier)
        (identifier)
        (identifier)))
    (block
      (pass_statement))))

================================================================================
Class definitions with superclasses
================================================================================

class A(B, C):
  def d():
    e

--------------------------------------------------------------------------------

(module
  (class_definition
    (identifier)
    (argument_list
      (identifier)
      (identifier))
    (block
      (function_definition
        (identifier)
        (parameters)
        (block
          (identifier))))))

================================================================================
Decorated definitions
================================================================================

@a.b
class C:
  @d(1)
  @e[2].f.g
  def f():
    g

  @f()
  async def f():
    g

@buttons[0].clicked.connect
def spam():
    ...

--------------------------------------------------------------------------------

(module
  (decorated_definition
    (decorator
      (attribute
        (identifier)
        (identifier)))
    (class_definition
      (identifier)
      (block
        (decorated_definition
          (decorator
            (call
              (identifier)
              (argument_list
                (integer))))
          (decorator
            (attribute
              (attribute
                (subscript
                  (identifier)
                  (integer))
                (identifier))
              (identifier)))
          (function_definition
            (identifier)
            (parameters)
            (block
              (identifier))))
        (decorated_definition
          (decorator
            (call
              (identifier)
              (argument_list)))
          (function_definition
            (identifier)
            (parameters)
            (block
              (identifier)))))))
  (decorated_definition
    (decorator
      (attribute
        (attribute
          (subscript
            (identifier)
            (integer))
          (identifier))
        (identifier)))
    (function_definition
      (identifier)
      (parameters)
      (block
        (ellipsis)))))

================================================================================
Trait definitions
================================================================================

trait A:
  pass

trait B:
  fn func(self):
    ...

trait C:
  fn func1(inout self):
    pass

  fn func2(self, inout arg: Arg):
    pass

trait D:
  fn func1(inout self, owned existing: Self, /):
    pass

  fn func2(owned self):
    pass

--------------------------------------------------------------------------------

(module
  (trait_definition
    (identifier)
    (block
      (pass_statement)))
  (trait_definition
    (identifier)
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter))
        (block
          (ellipsis)))))
  (trait_definition
    (identifier)
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention)))
        (block
          (pass_statement)))
      (function_definition
        (identifier)
        (parameters
          (self_parameter)
          (typed_parameter
            (argument_convention)
            (identifier)
            (type
              (identifier))))
        (block
          (pass_statement)))))
  (trait_definition
    (identifier)
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention))
          (typed_parameter
            (argument_convention)
            (identifier)
            (type
              (identifier)))
          (positional_separator))
        (block
          (pass_statement)))
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention)))
        (block
          (pass_statement))))))

================================================================================
Trait definitions with supertraits
================================================================================

trait A(B, C):
  pass

trait D(E):
  fn func(self):
    ...

trait F(G, H):
  fn func1(inout self):
    pass

  fn func2(self, owned arg: Arg):
    pass

trait I(J, K, L):
  fn func1(inout self, owned existing: Self, /):
    pass

  fn func2(owned self):
    pass

--------------------------------------------------------------------------------

(module
  (trait_definition
    (identifier)
    (trait_list
      (identifier)
      (identifier))
    (block
      (pass_statement)))
  (trait_definition
    (identifier)
    (trait_list
      (identifier))
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter))
        (block
          (ellipsis)))))
  (trait_definition
    (identifier)
    (trait_list
      (identifier)
      (identifier))
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention)))
        (block
          (pass_statement)))
      (function_definition
        (identifier)
        (parameters
          (self_parameter)
          (typed_parameter
            (argument_convention)
            (identifier)
            (type
              (identifier))))
        (block
          (pass_statement)))))
  (trait_definition
    (identifier)
    (trait_list
      (identifier)
      (identifier)
      (identifier))
    (block
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention))
          (typed_parameter
            (argument_convention)
            (identifier)
            (type
              (identifier)))
          (positional_separator))
        (block
          (pass_statement)))
      (function_definition
        (identifier)
        (parameters
          (self_parameter
            (argument_convention)))
        (block
          (pass_statement))))))

================================================================================
Raise statements
================================================================================

raise
raise RuntimeError('NO')
raise RunTimeError('NO') from e

--------------------------------------------------------------------------------

(module
  (raise_statement)
  (raise_statement
    (call
      (identifier)
      (argument_list
        (string
          (string_start)
          (string_content)
          (string_end)))))
  (raise_statement
    (call
      (identifier)
      (argument_list
        (string
          (string_start)
          (string_content)
          (string_end))))
    (identifier)))

================================================================================
Comments
================================================================================

print a
# hi
print b # bye
print c

--------------------------------------------------------------------------------

(module
  (print_statement
    (identifier))
  (comment)
  (print_statement
    (identifier))
  (comment)
  (print_statement
    (identifier)))

================================================================================
Comments at different indentation levels
================================================================================

if a:
  # one
# two
    # three
  b
    # four
  c

--------------------------------------------------------------------------------

(module
  (if_statement
    (identifier)
    (comment)
    (comment)
    (comment)
    (block
      (identifier)
      (comment)
      (identifier))))

================================================================================
Comments after dedents
================================================================================

if a:
  b

# one
c

--------------------------------------------------------------------------------

(module
  (if_statement
    (identifier)
    (block
      (identifier)))
  (comment)
  (identifier))

================================================================================
Comments at the ends of indented blocks
================================================================================

if a:
  b
  # one
  # two

if c:
  d
    # three
      # four

def a():
    if b:
        b # comment
    b # comment

# five

--------------------------------------------------------------------------------

(module
  (if_statement
    (identifier)
    (block
      (identifier)
      (comment)
      (comment)))
  (if_statement
    (identifier)
    (block
      (identifier)
      (comment)
      (comment)))
  (function_definition
    (identifier)
    (parameters)
    (block
      (if_statement
        (identifier)
        (block
          (identifier)
          (comment)))
      (identifier)
      (comment)))
  (comment))

================================================================================
Newline tokens followed by comments
================================================================================

print "a"
  # We need to recognize the newline *preceding* this comment, because there's no newline after it
--------------------------------------------------------------------------------

(module
  (print_statement
    (string
      (string_start)
      (string_content)
      (string_end)))
  (comment))

================================================================================
Global statements
================================================================================

global a
global a, b

--------------------------------------------------------------------------------

(module
  (global_statement
    (identifier))
  (global_statement
    (identifier)
    (identifier)))

================================================================================
Exec statements
================================================================================

exec '1+1'
exec 'x+=1' in None
exec 'x+=1' in a, b
func = "print"
exec func in {}

--------------------------------------------------------------------------------

(module
  (exec_statement
    (string
      (string_start)
      (string_content)
      (string_end)))
  (exec_statement
    (string
      (string_start)
      (string_content)
      (string_end))
    (none))
  (exec_statement
    (string
      (string_start)
      (string_content)
      (string_end))
    (identifier)
    (identifier))
  (assignment
    (identifier)
    (string
      (string_start)
      (string_content)
      (string_end)))
  (exec_statement
    (identifier)
    (dictionary)))

================================================================================
Extra newlines
================================================================================

if a:


    b()


    c()


    def d():


        e()


    f()

--------------------------------------------------------------------------------

(module
  (if_statement
    (identifier)
    (block
      (call
        (identifier)
        (argument_list))
      (call
        (identifier)
        (argument_list))
      (function_definition
        (identifier)
        (parameters)
        (block
          (call
            (identifier)
            (argument_list))))
      (call
        (identifier)
        (argument_list)))))

================================================================================
Escaped newline
================================================================================

len("a") \
or len("aa")

--------------------------------------------------------------------------------

(module
  (boolean_operator
    (call
      (identifier)
      (argument_list
        (string
          (string_start)
          (string_content)
          (string_end))))
    (line_continuation)
    (call
      (identifier)
      (argument_list
        (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Statements with semicolons
================================================================================

foo;
foo; bar
foo; bar;

--------------------------------------------------------------------------------

(module
  (identifier)
  (identifier)
  (identifier)
  (identifier)
  (identifier))

================================================================================
Type Alias Statements
================================================================================

type Point = tuple[float, float]
type Point[T] = tuple[T, T]
type IntFunc[**P] = Callable[P, int]  # ParamSpec
type LabeledTuple[*Ts] = tuple[str, *Ts]  # TypeVarTuple
type HashableSequence[T: Hashable] = Sequence[T]  # TypeVar with bound
type IntOrStrSequence[T: (int, str)] = Sequence[T]  # TypeVar with constraints

--------------------------------------------------------------------------------

(module
  (type_alias_statement
    (type
      (identifier))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))
          (type
            (identifier))))))
  (type_alias_statement
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier)))))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))
          (type
            (identifier))))))
  (type_alias_statement
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (splat_type
              (identifier))))))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))
          (type
            (identifier))))))
  (comment)
  (type_alias_statement
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (splat_type
              (identifier))))))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))
          (type
            (splat_type
              (identifier)))))))
  (comment)
  (type_alias_statement
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (constrained_type
              (type
                (identifier))
              (type
                (identifier)))))))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))))))
  (comment)
  (type_alias_statement
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (constrained_type
              (type
                (identifier))
              (type
                (tuple
                  (identifier)
                  (identifier))))))))
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))))))
  (comment))

================================================================================
Generic Function Definitions
================================================================================

def more_generic[T, *Ts, **P]():
    type TA[T2, *Ts2, **P2] = tuple[Callable[P, tuple[T, *Ts]], Callable[P2, tuple[T2, *Ts2]]]
    return TA

--------------------------------------------------------------------------------

(module
  (function_definition
    (identifier)
    (type_parameter
      (type
        (identifier))
      (type
        (splat_type
          (identifier)))
      (type
        (splat_type
          (identifier))))
    (parameters)
    (block
      (type_alias_statement
        (type
          (generic_type
            (identifier)
            (type_parameter
              (type
                (identifier))
              (type
                (splat_type
                  (identifier)))
              (type
                (splat_type
                  (identifier))))))
        (type
          (generic_type
            (identifier)
            (type_parameter
              (type
                (generic_type
                  (identifier)
                  (type_parameter
                    (type
                      (identifier))
                    (type
                      (generic_type
                        (identifier)
                        (type_parameter
                          (type
                            (identifier))
                          (type
                            (splat_type
                              (identifier)))))))))
              (type
                (generic_type
                  (identifier)
                  (type_parameter
                    (type
                      (identifier))
                    (type
                      (generic_type
                        (identifier)
                        (type_parameter
                          (type
                            (identifier))
                          (type
                            (splat_type
                              (identifier)))))))))))))
      (return_statement
        (identifier)))))

================================================================================
Assignment with var modifier
================================================================================

var x = 5
var y = "hello"
var z = [1, 2, 3]

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (integer))
  (assignment
    (identifier)
    (string
      (string_start)
      (string_content)
      (string_end)))
  (assignment
    (identifier)
    (list
      (integer)
      (integer)
      (integer))))

================================================================================
Assignment with comptime modifier
================================================================================

comptime x = 5
comptime y = "hello"
comptime z = True

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (integer))
  (assignment
    (identifier)
    (string
      (string_start)
      (string_content)
      (string_end)))
  (assignment
    (identifier)
    (true)))

================================================================================
Assignment with ref modifier
================================================================================

ref x = y
ref a = b.c
ref item = list[0]

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (identifier))
  (assignment
    (identifier)
    (attribute
      (identifier)
      (identifier)))
  (assignment
    (identifier)
    (subscript
      (identifier)
      (integer))))

================================================================================
Assignment with var and type annotation
================================================================================

var x: Int
var y: String
var z: List[Int]

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier)))))))

================================================================================
Assignment with comptime and type annotation
================================================================================

comptime x: Int
comptime y: String
comptime z: Bool

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier))))

================================================================================
Assignment with ref and type annotation
================================================================================

ref x: Int
ref y: String
ref z: MyType

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier))))

================================================================================
Assignment with var, type, and value
================================================================================

var x: Int = 5
var y: String = "hello"
var z: Float = 3.14

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier))
    (integer))
  (assignment
    (identifier)
    (type
      (identifier))
    (string
      (string_start)
      (string_content)
      (string_end)))
  (assignment
    (identifier)
    (type
      (identifier))
    (float)))

================================================================================
Assignment with comptime, type, and value
================================================================================

comptime x: Int = 5
comptime y: String = "world"
comptime z: Bool = False

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier))
    (integer))
  (assignment
    (identifier)
    (type
      (identifier))
    (string
      (string_start)
      (string_content)
      (string_end)))
  (assignment
    (identifier)
    (type
      (identifier))
    (false)))

================================================================================
Assignment with ref, type, and value
================================================================================

ref x: Int = other_value
ref y: String = obj.field
ref z: MyType = container[key]

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (type
      (identifier))
    (identifier))
  (assignment
    (identifier)
    (type
      (identifier))
    (attribute
      (identifier)
      (identifier)))
  (assignment
    (identifier)
    (type
      (identifier))
    (subscript
      (identifier)
      (identifier))))

================================================================================
Multiple assignments without modifiers
================================================================================

x = 5
y = 10
z = x + y

--------------------------------------------------------------------------------

(module
  (assignment
    (identifier)
    (integer))
  (assignment
    (identifier)
    (integer))
  (assignment
    (identifier)
    (binary_operator
      (identifier)
      (identifier))))

================================================================================
Function with read argument convention
================================================================================

fn process(read x: Int):
    print(x)

fn compute(read a: String, read b: String):
    return a + b

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (call
        function: (identifier)
        arguments: (argument_list
          (identifier)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (return_statement
        (binary_operator
          left: (identifier)
          right: (identifier))))))

================================================================================
Function with read argument convention
================================================================================

fn process(read x: Int):
    print(x)

fn compute(read a: String, read b: String):
    return a + b

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (call
        function: (identifier)
        arguments: (argument_list
          (identifier)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (return_statement
        (binary_operator
          left: (identifier)
          right: (identifier))))))

================================================================================
Function with mut argument convention
================================================================================

fn modify(mut x: Int):
    x = x + 1

fn update(mut data: List[Int]):
    data.append(5)

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (integer)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (generic_type
            (identifier)
            (type_parameter
              (type
                (identifier)))))))
    body: (block
      (call
        function: (attribute
          object: (identifier)
          attribute: (identifier))
        arguments: (argument_list
          (integer))))))

================================================================================
Function with var argument convention
================================================================================

fn process(var x: Int):
    x = 10

fn compute(var a: String, var b: Int):
    a = "modified"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with out argument convention
================================================================================

fn init_value(out x: Int):
    x = 42

fn get_values(out a: String, out b: Int):
    a = "result"
    b = 100

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (string
          (string_start)
          (string_content)
          (string_end)))
      (assignment
        left: (identifier)
        right: (integer)))))

================================================================================
Function with deinit argument convention
================================================================================

fn cleanup(deinit x: Resource):
    pass

fn destroy(deinit a: Object, deinit b: Object):
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (pass_statement)))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (pass_statement))))

================================================================================
Function with ref argument convention
================================================================================

fn process(ref[lifetime] x: Int):
    x = x + 1

fn compute(ref[a] data: String):
    data = data + "!"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention
          (identifier))
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (integer)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention
          (identifier))
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (string
            (string_start)
            (string_content)
            (string_end)))))))

================================================================================
Function with mixed argument conventions
================================================================================

fn process(read a: Int, mut b: Int, var c: String):
    b = b + a
    c = "result"

fn complex(read x: Int, out y: Int, deinit z: Resource):
    y = x * 2

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (identifier)))
      (assignment
        left: (identifier)
        right: (string
          (string_start)
          (string_content)
          (string_end)))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (assignment
        left: (identifier)
        right: (binary_operator
          left: (identifier)
          right: (integer))))))

================================================================================
Method with self and argument conventions
================================================================================

struct MyStruct:
    fn method(read self, mut x: Int):
        x = x + 1
    
    fn update(mut self):
        pass

--------------------------------------------------------------------------------

(module
  (class_definition
    name: (identifier)
    body: (block
      (function_definition
        name: (identifier)
        parameters: (parameters
          (self_parameter
            (argument_convention))
          (typed_parameter
            (argument_convention)
            (identifier)
            type: (type
              (identifier))))
        body: (block
          (assignment
            left: (identifier)
            right: (binary_operator
              left: (identifier)
              right: (integer)))))
      (function_definition
        name: (identifier)
        parameters: (parameters
          (self_parameter
            (argument_convention)))
        body: (block
          (pass_statement))))))

================================================================================
Function with default values and argument conventions
================================================================================

fn process(read x: Int = 5, mut y: String = "default"):
    y = "modified"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_default_parameter
        (argument_convention)
        name: (identifier)
        type: (type
          (identifier))
        value: (integer))
      (typed_default_parameter
        (argument_convention)
        name: (identifier)
        type: (type
          (identifier))
        value: (string
          (string_start)
          (string_content)
          (string_end))))
    body: (block
      (assignment
        left: (identifier)
        right: (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with untyped raises
================================================================================

fn may_fail() raises -> Int:
    return 1

def can_error() raises -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with typed raises
================================================================================

fn may_fail() raises Error -> Int:
    return 1

fn can_throw() raises ValueError -> String:
    return "test"

fn generic_error() raises MyError[T] -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (string
          (string_start)
          (string_content)
          (string_end)))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier)))))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with capturing and raises
================================================================================

fn with_capturing() capturing raises -> Int:
    return 1

fn capturing_typed() capturing raises Error -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with escaping and raises
================================================================================

fn with_escaping() escaping raises -> Int:
    return 1

fn escaping_typed() escaping raises IOError -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with capturing escaping raises
================================================================================

fn complex() capturing escaping raises -> Int:
    return 1

fn complex_typed() capturing escaping raises CustomError -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer))))
  (function_definition
    name: (identifier)
    parameters: (parameters)
    raises_type: (type
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with parameters and typed raises
================================================================================

fn process(x: Int, y: String) raises ProcessError -> Bool:
    return True

fn convert(mut data: List[Int]) raises ConversionError -> String:
    return "result"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (true))))
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (argument_convention)
        (identifier)
        type: (type
          (generic_type
            (identifier)
            (type_parameter
              (type
                (identifier)))))))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with unified clause - single variable
================================================================================

fn foo() unified {read a} -> String:
    return "test"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with unified clause - multiple variables
================================================================================

fn foo() unified {read a, mut b, var c} -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with unified clause - trailing comma
================================================================================

fn bar() unified {mut x, read y,} -> Int:
    return 0

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (integer)))))

================================================================================
Function with unified clause and typed raises
================================================================================

fn foo() unified {read a, mut b} raises ValueError -> String:
    return "test"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with unified clause and capturing raises
================================================================================

fn process() unified {mut data} capturing raises -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with unified clause, parameters, and effects
================================================================================

fn process(x: Int, y: String) unified {read config, mut state} escaping raises Error -> Bool:
    return true

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with unified clause - all convention types
================================================================================

fn test() unified {read a, mut b, var c, out d, deinit e} -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Async function with unified clause
================================================================================

async fn fetch() unified {mut client} raises IOError -> String:
    return "data"

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (string
          (string_start)
          (string_content)
          (string_end))))))

================================================================================
Function with unified clause - no return type
================================================================================

fn process() unified {mut state}:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier))
    body: (block
      (pass_statement))))

================================================================================
Function with unified clause and ref convention
================================================================================

fn update() unified {ref[lifetime] data} -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention
        (identifier))
      (identifier))
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with single where clause
================================================================================

fn test() -> Int where x == y:
    return 1

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (identifier)
        (identifier)))
    body: (block
      (return_statement
        (integer)))))

================================================================================
Function with multiple where clauses
================================================================================

fn copy(dst: UnsafePointer, src: UnsafePointer) raises -> Int where src.address_space == dst.address_space where src.mut:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (attribute
          object: (identifier)
          attribute: (identifier))
        (attribute
          object: (identifier)
          attribute: (identifier))))
    (where_clause
      (attribute
        object: (identifier)))
    body: (block
      (pass_statement))))

================================================================================
Function with where clause - simple condition
================================================================================

fn process[T](value: T) -> T where T.is_copyable:
    return value

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (identifier)))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (attribute
        object: (identifier)
        attribute: (identifier)))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with where clause and unified closure
================================================================================

fn foo() unified {read x} -> Int where x > 0:
    return x

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    (unified_clause
      (argument_convention)
      (identifier))
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (identifier)
        (integer)))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with where clause and typed raises
================================================================================

fn validate(x: Int) raises ValueError -> Bool where x >= 0 where x < 100:
    return true

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    raises_type: (type
      (identifier))
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (identifier)
        (integer)))
    (where_clause
      (comparison_operator
        (identifier)
        (integer)))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with where clause - complex expression
================================================================================

fn compute(a: Int, b: Int) -> Int where a + b < 100 where a > b:
    return a + b

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (binary_operator
          left: (identifier)
          right: (identifier))
        (integer)))
    (where_clause
      (comparison_operator
        (identifier)
        (identifier)))
    body: (block
      (return_statement
        (binary_operator
          left: (identifier)
          right: (identifier))))))

================================================================================
Async function with where clause
================================================================================

async fn fetch[T](url: String) -> T where T.is_json_decodable:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (identifier)))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (attribute
        object: (identifier)
        attribute: (identifier)))
    body: (block
      (pass_statement))))

================================================================================
Function with where clause - no return type
================================================================================

fn log(msg: String) where msg.len > 0:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    (where_clause
      (comparison_operator
        (attribute
          object: (identifier)
          attribute: (identifier))
        (integer)))
    body: (block
      (pass_statement))))

================================================================================
Function with where clause using keyword as attribute
================================================================================

fn check(x: Pointer) -> Bool where x.var where x.ref:
    return true

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (attribute
        object: (identifier)))
    (where_clause
      (attribute
        object: (identifier)))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with everything - unified, effects, and where clauses
================================================================================

fn ultimate[T, U](x: T, y: U) unified {read config, mut state} capturing raises Error -> Result[T] where T.is_valid where U == Int:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (identifier))
      (type
        (identifier)))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier)))
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    (unified_clause
      (argument_convention)
      (identifier)
      (argument_convention)
      (identifier))
    raises_type: (type
      (identifier))
    return_type: (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier)))))
    (where_clause
      (attribute
        object: (identifier)
        attribute: (identifier)))
    (where_clause
      (comparison_operator
        (identifier)
        (identifier)))
    body: (block
      (pass_statement))))

================================================================================
Function with type parameter where clause - single parameter
================================================================================

fn foo[i: Int where i > 5]():
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (identifier)
          (integer))))
    parameters: (parameters)
    body: (block
      (pass_statement))))

================================================================================
Function with type parameter where clause - multiple parameters
================================================================================

fn foo[i: Int where i > 5, j: Float32]():
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (identifier)
          (integer)))
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier)))))
    parameters: (parameters)
    body: (block
      (pass_statement))))

================================================================================
Function with type parameter where clause - all parameters have where
================================================================================

fn bar[T: SomeTrait where T.is_copyable, U: AnotherTrait where U.size > 0]() -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier)))
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (attribute
            object: (identifier)
            attribute: (identifier))
          (integer))))
    parameters: (parameters)
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Function with type parameter where - complex condition
================================================================================

fn compute[N: Int where N > 0 where N < 100](value: Int) -> Int:
    return value

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (identifier)
          (integer)))
      (where_clause
        (comparison_operator
          (identifier)
          (integer))))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with both type parameter where and function where
================================================================================

fn process[T: Type where T.is_valid](x: T) -> T where x != null:
    return x

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier))))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    return_type: (type
      (identifier))
    (where_clause
      (comparison_operator
        (identifier)
        (identifier)))
    body: (block
      (return_statement
        (identifier)))))

================================================================================
Function with type parameter where - no constraint type
================================================================================

fn simple[T where T.is_movable]() -> None:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (identifier))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier))))
    parameters: (parameters)
    return_type: (type
      (none))
    body: (block
      (pass_statement))))

================================================================================
Struct with type parameter where clause
================================================================================

struct Vector[T: Numeric where T.is_floating_point]:
    pass

--------------------------------------------------------------------------------

(module
  (class_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier))))
    body: (block
      (pass_statement))))

================================================================================
Function with trailing comma in type parameters with where
================================================================================

fn test[T: Type where T.is_valid,]():
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier))))
    parameters: (parameters)
    body: (block
      (pass_statement))))

================================================================================
Complex function with all features and type parameter where
================================================================================

async fn ultimate[T: Trait where T.is_valid, U: Other where U.size == 8](x: T) unified {read config} raises Error -> Result[T, U] where x.ready:
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (attribute
          object: (identifier)
          attribute: (identifier)))
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (attribute
            object: (identifier)
            attribute: (identifier))
          (integer))))
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    (unified_clause
      (argument_convention)
      (identifier))
    raises_type: (type
      (identifier))
    return_type: (type
      (generic_type
        (identifier)
        (type_parameter
          (type
            (identifier))
          (type
            (identifier)))))
    (where_clause
      (attribute
        object: (identifier)
        attribute: (identifier)))
    body: (block
      (pass_statement))))

================================================================================
Comptime assert - simple condition
================================================================================

__comptime_assert x > 5

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (comparison_operator
      (identifier)
      (integer))))

================================================================================
Comptime assert - boolean literal
================================================================================

__comptime_assert True
__comptime_assert False

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (true))
  (comptime_assert_statement
    (false)))

================================================================================
Comptime assert - equality comparison
================================================================================

__comptime_assert value == 10

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (comparison_operator
      (identifier)
      (integer))))

================================================================================
Comptime assert - complex expression
================================================================================

__comptime_assert x + y < 100

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (comparison_operator
      (binary_operator
        (identifier)
        (identifier))
      (integer))))

================================================================================
Comptime assert - attribute access
================================================================================

__comptime_assert obj.is_valid

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (attribute
      object: (identifier)
      attribute: (identifier))))

================================================================================
Comptime assert - in function
================================================================================

fn foo(x: Int):
    __comptime_assert x > 0
    return x

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters
      (typed_parameter
        (identifier)
        type: (type
          (identifier))))
    body: (block
      (comptime_assert_statement
        (comparison_operator
          (identifier)
          (integer)))
      (return_statement
        (identifier)))))

================================================================================
Comptime assert - with type parameters
================================================================================

fn process[N: Int where N > 0]():
    __comptime_assert N < 100
    pass

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    type_parameters: (type_parameter
      (type
        (constrained_type
          (type
            (identifier))
          (type
            (identifier))))
      (where_clause
        (comparison_operator
          (identifier)
          (integer))))
    parameters: (parameters)
    body: (block
      (comptime_assert_statement
        (comparison_operator
          (identifier)
          (integer)))
      (pass_statement))))

================================================================================
Comptime assert - logical operators
================================================================================

__comptime_assert x > 0 and x < 100
__comptime_assert not is_negative

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (boolean_operator
      (comparison_operator
        (identifier)
        (integer))
      (comparison_operator
        (identifier)
        (integer))))
  (comptime_assert_statement
    (not_operator
      (identifier))))

================================================================================
Comptime assert - multiple in block
================================================================================

fn validate():
    __comptime_assert x > 0
    __comptime_assert y > 0
    __comptime_assert x + y > 0

--------------------------------------------------------------------------------

(module
  (function_definition
    name: (identifier)
    parameters: (parameters)
    body: (block
      (comptime_assert_statement
        (comparison_operator
          (identifier)
          (integer)))
      (comptime_assert_statement
        (comparison_operator
          (identifier)
          (integer)))
      (comptime_assert_statement
        (comparison_operator
          (binary_operator
            left: (identifier)
            right: (identifier))
          (integer))))))

================================================================================
Comptime assert - with parentheses
================================================================================

__comptime_assert (x > 0)

--------------------------------------------------------------------------------

(module
  (comptime_assert_statement
    (parenthesized_expression
      (comparison_operator
        (identifier)
        (integer)))))
